\label[upgrade]\chap Required changes in ORTE

In this chapter, changes required for \glref{ORTE} to be compatible with the version 2.2 of the \glref{RTPS} protocol are discussed. Following is the state of work, where what is \Blue done is blue\Black, \Green working is green\Black, \Red not finished is red \Black and needless for interoperability is black.

\begitems
\Black
* Structure Module
  \begitems\style x
  \Blue
  * Participant (tested)
  * History Cache (tested)
  * Cache Change (tested)
  * Participant Proxy (tested)
  \Green
  * Writer Endpoint (working)
  * Reader Endpoint (working)
  * Reader Proxy (working)
  * Writer Proxy (working)
  \enditems

\Black
* Messages Module
  \begitems\style x
  \Blue
  * Header (tested)
  * Message Receiver (tested)
  * Data (tested)
  * InfoDestination (done)
  * InfoReply (done)
  * InfoSource (done)
  * InfoTimestamp (done)
  * Pad (done)
  \Green
  * AckNack (working)
  * Gap (working)
  * Heartbeat (working)
  \Black
  * DataFrag
  * HeartbeatFrag
  * NackFrag
  \enditems

\Black
* Behavior Module
  \begitems\style x
  \Blue
  * Best-Effort Stateless Writer (tested)
  * Best-Effort Stateless Reader (tested)
  \Red
  * Reliable Stateless Writer (not finished)
  * Reliable Stateful Reader, Writer Proxy (not finished)
  \Black
  * Best-Effort Stateful Writer
  * Reliable Stateful Writer, Reader Proxy
  * Best-Effort Stateful Reader
  \enditems

\Black
* Discovery Module
  \begitems\style x
  \Blue
  * SPDP (tested)
  \Red
  * SEDP (not finished)
  \enditems
\enditems

\Black

In section \ref[orte:spec], specific types used in \glref{ORTE} are introduced, their purpose and legacy of previous implementation. In \ref[orte:struct], \ref[orte:message], \ref[orte:behavior] and \ref[orte:discovery], implementation of each module from chapter \ref[compare] is discussed. Proposal of consequential development is introduced in section \ref[orte:next].

\label[orte:spec]\sec ORTE specific

\secc Version 1.0

In \glref{RTPS} 1.0 implementation, the core structure is "ORTEDomain". Following are specific types contained in "ORTEDomain" structure:
\begitems
* "TaskProp"
* "TypeEntry"
* "ObjectEntry"
* "PSEntry"
* "CSTPublications"
* "CSTSubscriptions"
\enditems

"TaskProp" maintains properties of {\em Tasks}, including own socket, thread and "MessageBuffer" (used for sending and receiving data) for each {\em Task}. There are five {\em Tasks}: "taskRecvUnicastMetatraffic", "taskRecvMulticastMetatraffic", "taskRecvUnicastUserdata", "taskRecvMulticastUserdata" and "taskSend".

"TypeEntry" is database of {\em Types} used for data encapsulation, containing name of {\em Type} and functions to serialize and deserialize it.

The database of all ``endpoints'' is stored in "ObjectEntry". In "ORTEDomain", variable "objectEntry" of type "ObjectEntry" is the root of 3-layered AVL tree (\cite[www:ulan]), where each layer correspond to {\em Host Id}, {\em Application Id} and {\em Object Id}. Also, {\em Application Id} layer serves as the root for {\em Hierarchical Timer} (\cite[www:ulan]) used for timing in \glref{ORTE}.

"PSEntry", "CSTPublications" and "CSTSubscriptions" are databases of {\em Publications} and {\em Subscriptions}. In context of version 1.0 of the \glref{RTPS} protocol, ``endpoints'' used for user data communication are stored here.

Builtin ``endpoints'' are defined directly in "ORTEDomain" structure, there are nine of {\em CSTWriters} and {\em CSTReaders} used for \glref{CST} protocol:
\begitems
* "writerApplicationSelf"
* "readerManagers"
* "readerApplications"
* "writerManagers"
* "writerApplications"
* "writerPublications"
* "readerPublications"
* "writerSubscriptions"
* "readerSubscriptions".
\enditems

\secc Version 2.2

Domain is abstract term involving communication of nodes that have something in common. The core structure in implementation of version 2.2 of \glref{RTPS} protocol was therefore renamed to "ORTEDomainParticipant". Following types persisted:
\begitems
* "TaskProp"
* "TypeEntry"
* "ObjectEntry"
\enditems

"TaskProp" has the same purpose as in previous implementation, just some of names changed to be more appropriate (see below).

"TypeEntry" remains completely same.

Because of substitution of {\em Host Id} and {\em Application Id} for {\em Guid Prefix}, "ObjectEntry" changed from 3-layered to 2-layered AVL tree (\cite[www:ulan]), where the first layer corresponds to {\em Guid Prefix} and the second one to {\em Entity Id}. The root for {\em Hierarchical Timer} (\cite[www:ulan]) is at the {\em Guid Prefix} layer.

"ORTEEndpoint" structure was added to "ObjectEntry" at the {\em Entity Id} layer. "ORTEEndpoint" can be {\em Stateless Writer} or {\em Stateless Reader} at present (see \ref[upgrade]) and {\em Stateful Writer}, {\em Stateful Reader}, {\em Participant Proxy}, {\em Reader Proxy} and {\em Writer Proxy} will be added in the future. So one database containing all {\em Endpoints} in {\em Domain} is used for each {\em Participant} and there is no need for directly defined {\em Endpoints} or separate database of publishers and subscribers.

\label[orte:struct]\sec Structure Module

\secc Participant

In the correspondence to \glref{PIM} (\ref[struct]) and as mentioned above, "ORTEDomain" structure changed to "ORTEDomainParticipant":
\begtt
struct ORTEDomainParticipant {
  uint32_t                    domainId;
  ObjectEntryEID              *myself;
  uint32_t                    participantId;

  GUID_RTPS                   guid;
  ProtocolVersion             protocolVersion;
  VendorId                    vendorId;

  Locator                     *defaultUnicastLocatorList;
  uint32_t                    defaultUnicastNumLocators;
  Locator                     *defaultMulticastLocatorList;
  uint32_t                    defaultMulticastNumLocators;
  Locator                     *sendingLocator;
  uint32_t                    sendingNumLocators;

  TaskProp                    taskRecvUnicastDiscoveryTraffic;
  TaskProp                    taskRecvMulticastDiscoveryTraffic;
  TaskProp                    taskRecvUnicastUserTraffic;
  TaskProp                    taskRecvMulticastUserTraffic;
  TaskProp                    taskSend;

  // db of types (ORTETypeRegister)
  TypeEntry                   typeEntry;
  // db of objects (ObjectEntryGP, ObjectEntryEID)
  ObjectEntry                 objectEntry;
};
\endtt

Identifiers of "ORTEDomainParticipant" are "domainId", "participantId" and "guid", where "guid" is generated as discussed in \cite[www:github]. The version of implementation is stored in "protocolVersion" and the vendor of implementation in "vendorId" attributes. {\em Domains} are distinguished by "domainId", only {\em Participants} in the same {\em Domain} can communicate. {\em Participants} within the {\em Domain} are distinguished by "participantId", so it's needed to be unique.

{\em Locator Lists} are implemented as pointers\fnote{In C, pointer can be understood as array with need for memory allocation.} and corresponding number of elements. It's assumed that {\em Locator Lists} don't change frequently, so there is no need for AVL.

{\em Task} for sending data doesn't make a difference between {\em Discoverry}, {\em User}, {\em Unicast} nor {\em Multicast} traffic, there is only one socket, thread and "MessageBuffer" for data sending. However each kind of receiving traffic like {\em Unicast Discovery}, {\em Multicast Discovery}, {\em Unicast User} or {\em Multicast User} has it's own {\em Task} and so it's own socket, thread and "MessageBuffer". This approach allows to process multiple kinds of traffic received on different ports at once.

Because "ORTEDomainParticipant" containing database of all {\em Entities} in {\em Domain} is shared between {\em Tasks} (and so between all threads), rwlock and mutex are used for this shared database of {\em Endpoints} and theirs related {\em Timers} stored in "objectEntry" in order to prevent multiple access. Attribute "*myself" is used to store pointer to the {\em Participant} in the database of all {\em Entities}.

The root for database of {\em Types} discussed above is "typeEntry".

Basic functions for "ORTEDomainParticipant" are:
\begitems
* "ORTEDomainParticipant_new"
* "ORTEDomainParticipant_start"
* "ORTEDomainParticipant_destroy"
\enditems

Where "ORTEDomainParticipant_new" and "ORTEDomainCreate" functions can be compared - both return core structure ("ORTEDomainParticipant" in version 2.2 and "ORTEDomain" in version 1.0) and initialize core attributes, structures and tasks.

The "ORTEDomainParticipant_start" function can be compared to "ORTEDomainStart" - both are used to start threads for corresponding {\em Tasks}.

The "ORTEDomainParticipant_destroy" and "ORTEDomainDestroy" functions can be compared  - both are used to release sources related to the core structure.

\secc Endpoints

Because {\em CSTWriter} evolves to {\em Stateful Writer} and {\em CSTReader} to {\em Stateful Reader}, new structures "StatelessWriter" and "StatelessReader" are introduced in correspondence to reference implementation.

\begtt
struct StatelessWriter {
  // it's Entity
  GUID_RTPS              guid;

  // it's Endpoint
  TopicKind               topicKind;
  ReliabilityKind         reliabilityLevel;
  Locator                 *unicastLocatorList;
    uint32_t                unicastNumLocators;
  Locator                 *multicastLocatorList;
    uint32_t                multicastNumLocators;

  // it's Writer
  Boolean                 pushMode;
  Duration                heartbeatPeriod;
    HTimFncUserNode         heartbeatTimer;
  Duration                nackResponseDelay;
    HTimFncUserNode         nackResponseTimer;
  Duration                nackSuppressionDuration;
    HTimFncUserNode         nackSuppressionTimer;
  SequenceNumber          lastChangeSequenceNumber;

  // it's StatelessWriter
  Duration                resendDataPeriod;
    HTimFncUserNode         resendDataTimer;

  // Associations
  ul_list_head_t          writerCache;  // HistoryCache
  ul_list_head_t          readerLocators;

  // others
  gavl_node_t            node;  // StatelessPublications
  ObjectEntryEID         *objectEntryEID;
  ORTETypeRegister        *typeRegister;

  // HistoryCache
  SequenceNumber          firstSN;
  SequenceNumber          lastSN;
};
\endtt

Identifier of "StatelessWriter" is "guid". {\em Writer} is {\em Endpoint} contained in {\em Participant}, therefore it has the same {\em Guid Prefix} and differs by {\em Entity Id}. Predefined {\em Entity Ids} are used for {\em Builtin Endpoints}. {\em Builtin Endpoints} differs from {\em User Endpoints} by the last octet (called entityKind) of {\em Entity Id}, see table \ref[tab:entityId]. This description apply for each {\em Entity}.

\midinsert \clabel[tab:entityId]{entityKind octet of an EntityId}
\ctable{lll}{
Kind of Entity & User-defined Entity & Built-in Entity \crl
unknown & 0x00 & 0xc0 \cr
Participant & N/A & 0xc1 \cr
Writer (with Key) & 0x02 & 0xc2 \cr
Writer (no Key) & 0x03 & 0xc3 \cr
Reader (no Key) & 0x04 & 0xc4 \cr
Reader (with Key) & 0x07 & 0xc7 \cr
}
\caption/t entityKind octet of an EntityId \cite[OMG:DDSI-RTPS22].
\endinsert

Attributes "topicKind", "reliabilityLevel" and "pushMode" are discussed in \ref[behavior].

{\em Locator Lists} and "NtpTime" or "Duration" attributes of {\em Writer} and their purpose is discussed in \ref[struct]. For each "NtpTime" or "Duration" attribute, function can be inserted into {\em Hierarchical Timer} structure and automatically launched.

The {\em History Cache} is implemented as doubly linked list \cite[www:ulan] with the head of "writerCache".

{\em Reader Locator} wasn't introduced yet. It is auxiliary structure used by {\em Stateless Writer} to store information about where to send data. However it mustn't be confused with {\em Reader Proxy} of {\em Stateful Reader}, because {\em Reader Locator} doesn't store any information about {\em Endpoint}, just {\em Locator} (\glref{IP} address, port, kind), if Qos should be included and requested and unsent {\em Cache Changes} needed for RELIABLE {\em Reliability Level}. List of {\em Reader Locators} is implemented as doubly linked list \cite[www:ulan] with the head of "readerLocators".

The remaining attributes are mostly auxiliary - "node" is needed because of AVL tree impementation, "*objectEntryEID" is pointer to {\em Writer} in database of all {\em Entities}, "firstSN" and "lastSN" are {\em Sequence Numbers} related to {\em History Cache}. Attribute "*typeRegister" is pointer to {\em Type} associated with {\em Writer}, which is used to serialize and deserialize {\em Data Object} related to {\em Writer}.

\begtt
struct StatelessReader {
  // it's Entity
  GUID_RTPS               guid;

  // it's Endpoint
  TopicKind               topicKind;
  ReliabilityKind         reliabilityLevel;
  Locator                 *unicastLocatorList;
    uint32_t                unicastNumLocators;
  Locator                 *multicastLocatorList;
    uint32_t                multicastNumLocators;

  // it's Reader
  Boolean                 expectsInlineQos;
  Duration                heartbeatResponseDelay;
    HTimFncUserNode         heartbeatResponseTimer;
  Duration                heartbeatSuppressionDuration;
    HTimFncUserNode         heartbeatSuppressionTimer;

  // it's StatelessReader

  // Associations
  ul_list_head_t          readerCache;  // HistoryCache

  // others
  gavl_node_t             node;
  ObjectEntryEID          *objectEntryEID;
  ORTETypeRegister        *typeRegister;
};
\endtt

Attributes of {\em Stateless Reader} have the same meaning as attributes of {\em Stateless Writer} but "expectsInlineQos" is added, claiming demand of {\em DDS Reader} for including Qos along with data.

\secc History Cache

The content of {\em History Cache} is made by {\em Cache Changes} - the replacement of {\em CSChange}, which is used as ``transfer unit'' for all data exchanges in \glref{RTPS} 2.2. Because {\em History Cache} is implemented as doubly linked list \cite[www:ulan], there is no special structure for {\em History Cache}. The next is the structure of {\em Cache Change}.

\begtt
struct CacheChange {
  // it's CacheChange
  ChangeKind              kind;
  GUID_RTPS               writerGuid;
  InstanceHandle          instanceHandle;
  SequenceNumber          sequenceNumber;

  // Associations
  uint8_t                 *data_value;
  ul_list_head_t          inlineQos;

  // Backward Associations
  ul_list_node_t          nodeListHistoryCache; // for StatelessWriter
  ul_list_node_t          nodeListRequestedChanges; // for ReaderLocator
  ul_list_node_t          nodeListUnsentChanges;    // for ReaderLocator
};
\endtt

Attributes of {\em Cache Chage} are discussed in \ref[struct]. "*data_value" is the pointer to {\em Data Object} of user {\em Application}. HERE CONTINUE

The implementation of {\em History Cache} remains the same - it's implemented as doubly linked list (\cite[www:ulan]). This manner allows to save memory by maintaining only one {\em Cache Change}, pointed from more structures as multiple matched {\em Reader Proxy} or {\em Writer Proxy}.

\secc Proxy Entities

While the name changed for {\em CSTRemote Reader} and {\em CSTRemoteWriter} to {\em Reader Proxy} respective {\em Writer Proxy}, the function of this {\em Endpoints} remains the same. {\em Participant Proxy}, {\em Reader Proxy} and {\em Writer Proxy} follows important attributes of {\em Participant}, {\em Reader} respective {\em Writer}.

\label[orte:message]\sec Messages Module

Because of substitution of {\em Host Id} and {\em Application Id} for {\em Guid Prefix} (\ref[rtps10]), the {\em Header} of \glref{RTPS} messages has changed appropriately - instead of 4B for {\em Host Id} and 4B for {\em Application Id}, 12B for {\em Guid Prefix} are sent. The {\em Header} length is therefore resized to 20B.

For {\em Submessages}, new structure "SubmessageHeader" is defined. When {\em Submessages} are sent, predefined macro "PUT_SHEADER(submessageHeader)" ensures putting the {\em Submessage Header} ``on the wire'' in contrast to version 1.0 implementation, where local variables "flags", "len", "length" and global structure "SubmessageId" were used. When receiving, {\em Submessage Header} is got ``from the wire'' only once in the thread of the receiving task. The pointer to "SubmessageHeader" and other pointers to "MessageInterpret" and "CDR_Codec" structures are then forwarded to the {\em Process} function of particular {\em Submessage}, preventing rewinding of "CDR_Codec"'s buffer and reading {\em Submessage Header}'s information again.

According to {\em Guid Prefix} and {\em Locator} changes (\ref[rtps10]), "MessageInterpret" structure has changed - {\em Host Id} and {\em Application Id} are substituted by {\em Guid Prefix} and {\em Reply IP Addresses} are substituted by {\em Reply Locators Lists}.

Generally for {\em Submessages}, name of the function responsible for processing of {\em Submessage} has changed by adding "Process" to the name (e.g. "RTPSInfoDST" function name changed to "RTPSInfoDSTProcess").

According to \ref[rtps10], changes in {\em Interpreter Submessages} cover replacement of {\em Host Id} and {\em Application Id} by {\em Guid Prefix} and corresponding processing and updating of {\em Message Interpret}.



\label[orte:behavior]\sec Behavior Module

\label[orte:discovery]\sec Discovery Module

\label[orte:next]\sec Next Steps

MessageInterpret -> MessageReceiver
Namespace
